from mountory_core.common.parsing import empty_str_as_none
from typing import overload, Literal
from typing_extensions import deprecated

from pydantic import EmailStr
from sqlalchemy import delete, func
from sqlmodel import Session, col, select
from sqlmodel.ext.asyncio.session import AsyncSession

from mountory_core.security import get_password_hash, verify_password
from mountory_core.users.models import User, UserCreate, UserUpdate
from mountory_core.users.types import UserId, PasswordStr, UserFullNameStr
from mountory_core.logging import logger


async def _create_user_old(
    *,
    db: AsyncSession,
    data: UserCreate,
    commit: bool = True,
) -> User:
    """
    Create a new user.

    :param db: Database session
    :param data: ``UserCreate`` instance with data for new user.
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: Created ``User`` instance.
    """
    logger.info(f"create user {data.email}")
    logger.debug(f"create user {data.email}, create object")

    model_data = data.model_dump(exclude_unset=True)
    logger.debug(f"create user {data.email}, create object {model_data}")
    user = User.model_validate(
        model_data, update={"hashed_password": get_password_hash(data.password)}
    )

    logger.debug(f"create user {data.email}, add object to database")
    db.add(user)
    if commit:
        logger.debug(f"create user {data.email}, commit transaction")
        await db.commit()
        await db.refresh(user)
    return user


async def _create_user_new(
    db: AsyncSession,
    *,
    email: EmailStr,
    password: PasswordStr,
    full_name: UserFullNameStr | None = None,
    is_active: bool = True,
    is_superuser: bool = False,
    user_id: UserId | None = None,
    commit: bool = True,
) -> User:
    """Create a new ``User`` in the given database.

    :param db: Database session.
    :param email: Email address of the user to create. (Required)
    :param password: Password of the user to create. (Required)
    :param full_name: Full name of the user to create.
        Emtpy string `""` will be treated as `None`. (Optional)
    :param is_active: Whether the user is active. (Default: ``True``)
    :param is_superuser: Whether the user is a superuser. (Default: ``False``)
    :param user_id: Explicitly provide ID of user.
        In general, this parameter should not be used, the ID will be generated by the database. (Default: ``None``)
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: Created ``User`` instance.
    """
    logger.info(f"create user {email}")

    logger.debug(f"create user {email}, hash password")
    hashed_password = get_password_hash(password)

    # An empty string is a valid and allowed in put, but should be treated, like it's not set!
    if full_name == "":
        logger.debug(f"create user {email}, handle empty string")
        full_name = None

    logger.debug(f"create user {email}, create object")
    user = User(
        email=email,
        hashed_password=hashed_password,
        full_name=full_name,
        is_active=is_active,
        is_superuser=is_superuser,
    )
    if user_id:
        logger.debug(f"create user {email}, handle user_id {user_id}")
        user.id = user_id

    logger.debug(f"create user {email}, add to database")
    db.add(user)
    if commit:
        logger.debug(f"create user {email}, commit transaction")
        await db.commit()
        await db.refresh(user)
    return user


@overload
@deprecated(
    """
    Passing a ``CreateUser`` instance as data parameter is deprecated and will be removed in a future release.
    Please switch to passing the parameters on their own.
    """
)
async def create_user(
    db: AsyncSession,
    *,
    data: UserCreate,
    commit: bool = True,
) -> User:
    """
    Passing a ``CreateUser`` instance as data parameter is deprecated and will be removed in a future release.
    Please switch to passing the parameters on their own.

    Create a new user.

    :param db: Database session
    :param data: ``UserCreate`` instance with data for new user.
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: Created ``User`` instance.
    """


@overload
async def create_user(
    db: AsyncSession,
    *,
    email: EmailStr,
    password: PasswordStr,
    full_name: UserFullNameStr | None = None,
    is_active: bool = True,
    is_superuser: bool = False,
    user_id: UserId | None = None,
    commit: bool = True,
) -> User:
    """Create a new ``User`` in the given database.

    :param db: Database session.
    :param email: Email address of the user to create. (Required)
    :param password: Password of the user to create. (Required)
    :param full_name: Full name of the user to create.
        Emtpy string `""` will be treated as `None`. (Optional)
    :param is_active: Whether the user is active. (Default: ``True``)
    :param is_superuser: Whether the user is a superuser. (Default: ``False``)
    :param user_id: Explicitly provide ID of user.
        In general, this parameter should not be used, the ID will be generated by the database. (Default: ``None``)
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: Created ``User`` instance.
    """


async def create_user(
    db: AsyncSession,
    *,
    data: UserCreate | None = None,
    email: EmailStr | None = None,
    password: PasswordStr | None = None,
    full_name: UserFullNameStr | None = None,
    is_active: bool = True,
    is_superuser: bool = False,
    user_id: UserId | None = None,
    commit: bool = True,
) -> User:
    if data is None:
        if email is None:
            raise ValueError("email is required")
        if password is None:
            raise ValueError("password is required")
        return await _create_user_new(
            db,
            email=email,
            password=password,
            full_name=full_name,
            is_active=is_active,
            is_superuser=is_superuser,
            user_id=user_id,
            commit=commit,
        )
    else:
        return await _create_user_old(db=db, data=data, commit=commit)


async def read_user_by_id(*, db: AsyncSession, user_id: UserId) -> User | None:
    """
    Get a user by id.

    :param db: Database session.
    :param user_id: ``UserID`` of the user to get.

    :return: ``User`` if it exists, otherwise ``None``.
    """
    logger.info(f"read user {user_id}")
    return await db.get(User, user_id)


def sync_read_user_by_id(*, db: Session, user_id: UserId) -> User | None:
    """
    Get a user by id.

    Synchronous version of ``read_user_by_id``.

    :param db: Database session.
    :param user_id: ``UserID`` of the user to get.

    :return: ``User`` if it exists, otherwise ``None``.
    """
    logger.info(f"read user {user_id}")
    return db.get(User, user_id)


async def read_users(
    *, db: AsyncSession, skip: int, limit: int
) -> tuple[list[User], int]:
    """
    Get all users.

    :param db: Database session.
    :param skip: Number of entries to skip when returning results.
    :param limit: Number of entries to return.

    :return: List of all users limited by ``limit`` and the total count of users.
    """
    logger.info(f"Read users, {skip=}, {limit=}")
    count_statement = select(func.count()).select_from(User)
    count = (await db.exec(count_statement)).one()

    statement = select(User).offset(skip).limit(limit)
    users = (await db.exec(statement)).all()
    return list(users), count


async def _update_user_old(
    *, db: AsyncSession, user: User, data: UserUpdate, commit: bool = True
) -> User:
    """
    Update a ``User`` instance.

    Fields of ``data`` set to ``None`` will be ignored, except for ``full_name``.

    :param db: Database session.
    :param user: ``User`` instance to update.
    :param data: ``UserUpdate`` instance with data to update.
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: Updated ``User`` instance.
    """
    logger.info(f"update user, {user.id}")

    model_data = data.model_dump(exclude_unset=True, exclude_none=True)
    if "full_name" in data.model_fields_set:
        logger.debug(f"update user {user.id}, update full_name={data.full_name}")
        model_data["full_name"] = data.full_name

    if not model_data:
        logger.debug(f"update user {user.id}, nothing to update")
        return user

    extra_data = {}
    if "password" in model_data:
        logger.debug(f"update user {user.id}, hash password")
        password = model_data["password"]
        hashed_password = get_password_hash(password)
        extra_data["hashed_password"] = hashed_password

    logger.debug(f"update user {user.id}, update object")
    user.sqlmodel_update(model_data, update=extra_data)

    logger.debug(f"update user {user.id}, update object in database")
    db.add(user)
    if commit:
        await db.commit()
        await db.refresh(user)
    return user


async def _update_user_new(
    db: AsyncSession,
    *,
    user: User,
    email: EmailStr | None = None,
    password: PasswordStr | None = None,
    full_name: UserFullNameStr | Literal[""] | None = None,
    is_active: bool | None = None,
    is_superuser: bool | None = None,
    commit: bool = True,
) -> User:
    """Update a ``User`` instance.

    :param db: Database session.
    :param user: User to update.
    :param email: New email address. If ``None``, will not be updated. (Default: ``None``)
    :param password: New password. If ``None``, will not be updated. (Default: ``None``)
    :param full_name: New full name. If ``None``, will not be updated.
        To remove the full name field pass an empty string. (Default: ``None``)
    :param is_active: Activity status of the user. If ``None`` will not be updated. (Default: ``None``)
    :param is_superuser: Whether the user is a superuser or not. If ``None`` will not be updated. (Default: ``None``)
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: User instance passed to function with updated values.
    """
    if email is not None:
        user.email = email
    if password is not None:
        user.hashed_password = get_password_hash(password)
    if full_name is not None:
        user.full_name = empty_str_as_none(full_name)
    if is_active is not None:
        user.is_active = is_active
    if is_superuser is not None:
        user.is_superuser = is_superuser

    db.add(user)
    if commit:
        await db.commit()
        await db.refresh(user)

    return user


@overload
@deprecated(
    """
    Passing update data as ``UpdateUser`` instance is deprecated and will be removed in a future release.
    Pleas pass update data as individual parameters.
    """
)
async def update_user(
    db: AsyncSession, *, user: User, data: UserUpdate, commit: bool = True
) -> User: ...


@overload
async def update_user(
    db: AsyncSession,
    *,
    user: User,
    email: EmailStr | None = None,
    password: PasswordStr | None = None,
    full_name: UserFullNameStr | Literal[""] | None = None,
    is_active: bool | None = None,
    is_superuser: bool | None = None,
    commit: bool = True,
) -> User: ...


async def update_user(
    db: AsyncSession,
    *,
    user: User,
    data: UserUpdate | None = None,
    email: EmailStr | None = None,
    password: PasswordStr | None = None,
    full_name: UserFullNameStr | Literal[""] | None = None,
    is_active: bool | None = None,
    is_superuser: bool | None = None,
    commit: bool = True,
) -> User:
    if data is not None:
        return await _update_user_old(db=db, user=user, data=data, commit=commit)
    return await _update_user_new(
        db,
        user=user,
        email=email,
        password=password,
        full_name=full_name,
        is_active=is_active,
        is_superuser=is_superuser,
        commit=commit,
    )


async def get_user_by_email(*, db: AsyncSession, email: EmailStr) -> User | None:
    """
    Get a user by email.

    :param db: Database session.
    :param email: Email of the user to get.

    :return: ``User`` if it exists, otherwise ``None``.
    """
    logger.info(f"get user by email {email}")
    statement = select(User).filter(col(User.email) == email)
    session_user = (await db.exec(statement)).first()
    logger.debug(
        f"get user {email}, result={session_user.id if session_user else None}"
    )
    return session_user


async def authenticate_user(
    *, db: AsyncSession, email: EmailStr, password: str
) -> User | None:
    """
    Authenticate a user by email and password.

    If the user does not exist, or the password is incorrect, returns ``None``.

    NOTE: In the future might raise an exception if authentication fails.

    :param db: Database session.
    :param email: Email of the user to authenticate.
    :param password: Password of the user to authenticate.

    :return: ``User`` if authentication is successful, otherwise ``None``.
    """
    logger.info(f"authenticate user {email}")

    db_user = await get_user_by_email(db=db, email=email)
    # todo: maybe raise exceptions to allow to distinguish between not existing user and wrong password?
    if not db_user:
        logger.warning(f"authenticate user {email}, user not found")
        return None
    if not verify_password(password, db_user.hashed_password):
        logger.warning(f"authenticate user {email}, failed")
        return None
    logger.debug(f"authenticate user {email}, user authenticated")
    return db_user


async def delete_user_by_id(
    *, db: AsyncSession, user_id: UserId, commit: bool = True
) -> None:
    """
    Delete a user by id.

    :param db: Database session.
    :param user_id: ``UserId`` of user to delete.
    :param commit: Whether to commit the database transaction. (Default: ``True``)

    :return: ``None``
    """
    logger.info(f"delete user {user_id}")

    stmt = delete(User).filter_by(id=user_id)
    logger.debug(f"delete user {user_id}, execute stmt")
    await db.exec(stmt)
    if commit:
        logger.debug(f"delete user {user_id}, commit transaction")
        await db.commit()
